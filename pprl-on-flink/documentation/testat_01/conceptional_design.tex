\documentclass[10pt]{article}

\usepackage{url}
%\usepackage{graphicx}
%\usepackage{cite}
%\usepackage{tabularx}

%\newcommand{\rom}[1]{\MakeUppercase{\romannumeral #1}}

\usepackage{listings}
%\usepackage[ruled,vlined,linesnumbered,nofillcomment]{algorithm2e}
\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\ttfamily\tiny,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Java,                 % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\begin{document}

    \input{./titlepage.tex}

    \section{Introduction}

        In order to fulfill the first assignment of the \textit{Big Data Praktikum} three main topics had to be
        implemented. Firstly, the system had to be set up, i.e. setting up Fllink on a computer system. Secondly,
        the planned architecture for the implementation of PPRL with Flink hat to be outlined. Thirdly, an
        implementation plan had ot be outlined in order to apply the given problem.
        In the following sections all three issues are discussed.

    \section{Installation}

        In this sectin we will shortly outline setting up the Flink on a machine in order to test it and
        getting a first impression of the framework.

        \subsection{Setting up \& testing Flink}

            Apache Flink is downloadable from the Apache website \url{https://flink.apache.org}. The installation
            is straight forward and therefore does not need any explanation here, since there is a very good
            documentation on the Apache Flink website.

            % Setting up test environment -> include java code

        \subsection{Dataset}

            % test data from Sehili        
            % hadoop hdfs

            The \textit{North Carolina Voter Registratin Databse} \url{http://dl.ncsbe.gov}
            supports our puposes to test
            first implementations of the Bloom-Filter and the LSH. This Dataset is one of the few
            which includes real names, addresses as well as age. Since we want to encrypt this data
            it is highly important that we use such data for our purposes.

            Furthermore, the use of a DataCorruptor constructing subsets of the dataset as well as
            modifying data is preferable. Implementing the corruptor in Java (transormation from python to java)
            is therefore another issue of our work (see implementation-section).

            % short explanatin of both datasets -> which data is relevant? -> .txt and .vcs data

    \section{Architecture}

        % using hamming distance!

        \begin{itemize}
			\item Data Owner / Parteien
				\begin{itemize}
					\item Einigung über Paramter (Länge der N-Gramme, Anzahl Hashfunktionen,
					Größe der Bloom Filter (Bloom-Filter muss flexibel bleiben; Token-Laenge muss flexibel sein), ...
					\item Halten verschiedene Datensätze
					\item Codierung der Records aus ihren Datensätze (Erstellung der Bloom Filter)
					\item Blocking mittels LSH-MinHash 
					(? Wo soll das Blocking durchgeführt werden ?)
					\item Senden der Daten an die Linkage Unit
				\end{itemize}
			\item Linkage Unit
				\begin{itemize}
					\item Blocking mittels LSH-MinHash (?)
					\item Durchführung des Linkage Algorithmus
					\item Senden der Ergebnisse an die Data Owner / beteiligten Parteien
				\end{itemize}	
		\end{itemize} 

    \section{Implementation Plan}

        % implementing own bloom-filter (flatmap->flatmap->reduce [in parallel] )
        % implementing own LSH -> keys or subkeys

		\begin{itemize}
			\item Datenimport: Lesen des Voter-Files und Übertragung der relevanten Felder in
			 ein DataSet
			\begin{itemize}
				\item Vorname
				\item Nachname
				\item Adresse
				\item Geburtsdatum
			\end{itemize}
			\item Datenvorverarbeitung: Konkatenation und Normalisierung der relevanten
			 Felder. Eventuell Einfügung von künstlichen IDs.
			\item Erstellung N-Gramme: Überführung der konkatenierten QIDs in N-Gramme mit
			 Hilfe einer FlatMap-Funktion.
			\item Zusammenfassung der N-Gramme: Zusammenfassung aller N-Gramme des
			 gleichen Records mit Hilfe einer Reduce-Funktion. (Eventuell zsfg. mit vorherigem
			  Schritt?)
			\item Erstellung der Bloom Filter: Aufnahme aller N-Gramme eines Records in einen
			 Bloom Filter (Map-Funktion).
		\end{itemize}

 		\begin{itemize}
        		\item Blocking: Erstellung von Blöcken von Kandidat-Record-Paaren mit Hilfe von
        		 LSH-MinHash. (FlatMap / Reduce)
			\item Linkage I: Vergleich aller Kandidaten-Record-Paare eines Blocks mit Hilfe einer
			 Ähnlichkeitsfunktion (FlatMap).
			\item Linkage II: Vergleich aller Ähnlichkeitswerte mit dem Schwellwert. Behalte nur
			 die Werte mit einem hinreichend guten Wert. (Reduce)
			\item Bekanntgabe der Ergebnisse: Speicherung oder Versand der Matching Pairs.
			 (Paar von IDs)
		\end{itemize}

%\begin{lstlisting}
%\end{lstlisting}


        %\bibliographystyle{plain}
        %\bibliography{library}

\end{document}
